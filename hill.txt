def mod_inverse(a, m):
    for x in range(1, m):
        if (a * x) % m == 1:
            return x
    return None

def matrix_determinant_2x2(m):
    return (m[0][0]*m[1][1] - m[0][1]*m[1][0]) % 26

def matrix_determinant_3x3(m):
    return (
        m[0][0]*(m[1][1]*m[2][2] - m[1][2]*m[2][1]) -
        m[0][1]*(m[1][0]*m[2][2] - m[1][2]*m[2][0]) +
        m[0][2]*(m[1][0]*m[2][1] - m[1][1]*m[2][0])
    ) % 26

def inverse_matrix(matrix):
    size = len(matrix)
    det = matrix_determinant_2x2(matrix) if size == 2 else matrix_determinant_3x3(matrix)
    det_inv = mod_inverse(det, 26)
    if det_inv is None:
        raise ValueError("Matrix is not invertible")

    if size == 2:
        a, b = matrix[0]
        c, d = matrix[1]
        return [
            [(d * det_inv) % 26, (-b * det_inv) % 26],
            [(-c * det_inv) % 26, (a * det_inv) % 26]
        ]

   
    cof = []
    for i in range(3):
        row = []
        for j in range(3):
            minor = [matrix[x][:j] + matrix[x][j+1:] for x in range(3) if x != i]
            det_minor = matrix_determinant_2x2(minor)
            cofactor = ((-1) ** (i + j)) * det_minor
            row.append(cofactor % 26)
        cof.append(row)

 
    adj = [[cof[j][i] for j in range(3)] for i in range(3)]
    inv = [[(det_inv * adj[i][j]) % 26 for j in range(3)] for i in range(3)]
    return inv

def prepare_text(text, size):
    text = text.upper().replace(" ", "")
    while len(text) % size != 0:
        text += 'X'
    return text

def encrypt(text, key):
    size = len(key)
    text = prepare_text(text, size)
    result = ''
    for i in range(0, len(text), size):
        block = [ord(c) - ord('A') for c in text[i:i+size]]
        encrypted = [(sum(key[row][k] * block[k] for k in range(size)) % 26) for row in range(size)]
        result += ''.join(chr(c + ord('A')) for c in encrypted)
    return result

def decrypt(cipher, key):
    inv_key = inverse_matrix(key)
    return encrypt(cipher, inv_key)

print("Hill Cipher (2x2 or 3x3) - Enter key matrix as integers")

n = int(input("Enter matrix size (2 or 3): "))
if n not in [2, 3]:
    raise ValueError("Only 2x2 or 3x3 allowed!")

key = []
print(f"Enter {n*n} integers row by row (values 0â€“25):")
for i in range(n):
    row = list(map(int, input(f"Row {i+1}: ").split()))
    if len(row) != n:
        raise ValueError(f"Each row must have {n} numbers.")
    key.append(row)

text = input("Enter plaintext (A-Z only): ")
cipher = encrypt(text, key)
print("Encrypted:", cipher)

plain = decrypt(cipher, key)
print("Decrypted:", plain)
